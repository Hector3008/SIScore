*** npm i : instala el paquete de node (node_modules) segpun el archivo package.Json
****  el codigo se ejecuta con los script (start o dev). start ejecuta node y dev nodemon
  **** node ejecuta una sola vez y nodemon seg√∫n cada actualizaci√≥n
  **** ejecutan el archivo main (./srt/app.js)

*** .gitignore contiene el nombre de los archivos a ignorar
  **** siempre debe tener el archivo node_modules y despu√©s las claves ssh
  

*** la clave constructor para crear modelos trabaja con la clave new al momento de crear objetos

*** express ayuda a trabajar entre rutas. Se inicia con el codigo const app = express();
  ****  se inicia con el codigo app.get("/", (req, res) => {
    });
  ****  y se alimenta de routers de tipo app.use("/products", productRouter);
  ****  tambi√©n recibe configuraciones como app.use(express.json()) o app.use("/", express.static("./src/public")) y app.use(express.urlencoded({ extended: true }))
  ****  trabaja rutas de tipo .get (read), .put (update), .post (create), y .delete (delete)

*** handlebars es el motor de frontend. Se activa con las lineas
    const hbs = handlebars.create({
        helpers: {
          eq: function (arg1, arg2, options) {
            // Verificar si options est√° definido y es una funci√≥n
            if (
              options &&
              typeof options.fn === "function" &&
              typeof options.inverse === "function"
            ) {
              if (arg1 === arg2) {
                return options.fn(this); // Ejecuta el bloque de c√≥digo de {{#eq}}
              } else {
                return options.inverse(this); // Ejecuta el bloque de c√≥digo de {{else}}
              }
            } else {
              return ""; // Devuelve una cadena vac√≠a si las opciones no son v√°lidas
            }
          },
        },
      });
      app.engine("handlebars", hbs.engine);

    app.set("views", "./src/views");
    app.set("view engine", "handlebars");
    y funciona creando un archivo views/layouts/main.handlebars que establece el html estatico
    para cargar el html dinamico con las vistas .handlebaras de la carpeta Views
    Al handlebars se le llama desde el controlador con la funcion .render (
    (res.render("products.handlebars",{products: result.payload})))
    se le pasan props en un json y sobre esas props se puede iterar en el archivo .handlebars

*** SOCKET: permite comunicacion entre el servidor y el cliente. Se agrega al app.js y trabaja con comandos .socket (cliente) y .io (servidor) con un .on (reciben mensaje) y .emit (envian mensaje)


  ingenier√≠a en app.js: 
    const server = http.createServer(app)// se crea el servidor HTTP real
    const io = new Server(server);// servidor socket.io real
    socket(io);//le cargo los sockets

    server.listen(8000, () => {   console.log("server up on http://localhost:8000")}) //se levanta el servidor
      /*explicacion de m√©todos y objetos: 
      io = el servidor
      socket = conexi√≥n individual
      .emit = enviar mensaje
      .on = recibir mensaje

      explicacion: 
      io.on("connection", async (socket) => {

      socket.on("productList", (data) => {
      io.emit("updatedProducts", data);
      });
      el servidor recibe el evento "conexion" 
      el cliente recibe la lista de productos
      y el servidor env√≠a la lista actualizada

      el cliente (socket) env√≠a mensajes desde el script que se carga en el html
      el servidor lo hace desde el codigo interno

      el script del html puede importa <script src="/socket.io/socket.io.js"></script> como carpeta din√°mica:
      y se agrega otro script como este:
      <script>
            
        const socket = io();

        socket.on("connect", () => {
          console.log("‚úÖ Conectado al socket server con id:", socket.id);
        });

        socket.on("alerta", () => {
          console.log("üì¢ Alerta recibida: nuevo usuario conectado");
        });

        socket.on("updatedProducts", (data) => {
          console.log("üì¶ Productos actualizados:", data);
        });
      </script>

      */